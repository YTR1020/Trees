# 正则表达式和php（正则表达式基础、php写正则替换、分析正则一句话、关于日志审计、php弱类型比较、php语言特性、php之md5类型练习、php反序列化）

# 正则表达式基础

可以使用工具sublime【记事本】



## 日志审计

靶场：(http://rzsj1.njhack.xyz/index.php)

![image-20220117233216120](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80.assets/image-20220117233216120.png)

(http://rzsj1.njhack.xyz/access.log)将access.log下载下来

通过看网站的日志，对其进行分析，来看黑客的ip地址、攻击方式、攻击影响等。



比如：

![image-20220117233541374](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80.assets/image-20220117233541374.png)

```
172.16.12.1 - - [31/Oct/2017:15:11:16 +0800] "GET /robots.txt HTTP/1.1" 404 286 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.21 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.21"

# 172.16.12.1     请求网站的ip地址
# [31/Oct/2017:15:11:16 +0800]     发送请求的具体时间
# "GET /robots.txt HTTP/1.1" 404 286     发送的是GET请求方式，内容是请求访问该网站目录下的/robots.txt文件，并且请求失败，找不到
# "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.21 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.21"     发送请求的浏览器相关
```



再比如：

![image-20220117234036766](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80.assets/image-20220117234036766.png)

```
172.16.12.1 - - [31/Oct/2017:15:11:16 +0800] "GET / HTTP/1.1" 200 - "http:......" "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.21 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.21"

# "GET / HTTP/1.1" 200    是发送GET请求访问主页面，/就是主页面，并且访问成功。
```

那么如果要对日志进行查看审计的话，就需要学习一些基础。





## 正则表达式基础

 即用一个表达式对你想要获取的东西进行表示。——匹配东西



使用sublime的功能可以使用正则表达式【Ctrl+f】：

![image-20220117234901667](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80.assets/image-20220117234901667.png)

### 实质：匹配东西——

比如a.txt：

```
haha,Here are some phone number 1311121342,You can call me now!
Of course I'm alwayse reachable at (010)1234-9988....
xaha wocao!!!
```

#### 基本语句【程序里大小写敏感】

##### 转义字符

```
\  转义字符，可以把程序字符转为字符，可以把字符转为程序字符

\转义字符可以把无意义的转义为有意义的，也可以把有意义的转义成无意义的。
```

##### 大小写敏感

```
(?i)    #用正则表达式让大小写不敏感
```

##### 匹配字符

```
\w           # 匹配所有字符，但是不匹配符号
\w\w\w       # 匹配所有连续的3个字符，但是不匹配符号，以符号分割
\w{5}       # 匹配所有连续的5个字符，但是不匹配符号，以符号分割
\w+         # 匹配所有整块字符，但是不匹配符号，以符号分割

\s          # 匹配空格

^        以什么为段落开头      # 比如^xx，就是匹配xx的段落开头
$        以什么为段落结尾      # 比如^xx，就是匹配xx的段落结尾

\b         单词界定符   # 需要辅助，以头尾包裹的形容
\b\w{3}\b      # 表示匹配所有连续的3个并且是整块的单词，但是不匹配符号

\d         数字界定符  
\d{11}           # 可以匹配手机号
\d{4}-\d{4}      # 可以匹配除区号以外的电话
\(\d{3}\)     # 利用正则表达式的括号\(\)匹配区号
```

##### 贪婪匹配

```
相关程序字符：

*     # 匹配0或多次
+     # 匹配1或多次
.     # 匹配除了换行符以外的所有单字符
?     # 前面的表达式出现了0或1次


\w与\w*的区别：\w一个字符一个字符地匹配，\w*只要后面有字符非符号就整块匹配
\w.*   # 即匹配0或多次除了换行符以外的所有单字符，即匹配一段话

.*     # 匹配所有，贪婪匹配
```

##### 匹配邮箱

```
xiaoming123@qq.com

\w+@\w+\.(com|net|org)    #匹配邮箱
```

##### []程序

```
[i am xi]
[]
[[123]]
{xxx xx d}

\[.*?\]         # 匹配在框里的所有东西。
                # 出现多个框时可能出现匹配错误——多重标签


Haaha
haha
xaha
aaha
aaaha
[a]aha     # 匹配到aaha
[a]?aha    # 匹配0次或多次
[a]+aha    # 匹配一次或多次


[1-3]{3}   # 匹配1-3的数字连续出现3次
[1-9]{2,}   # 匹配1-9的数字连续出现2次或多次
[1-3]{2,4}   # 匹配1-3的数字连续出现2次或4次

[a-c]* 匹配a-c
```

##### ()程序

```
()当做程序来使用
^(h|x)aha   # 匹配以h或者x开头后面是aha的行段
```

##### 先行断言、后发断言

```
?=   #正先行断言
(x|h)aha(?=\swo)      # 空格+wo是先决条件，然后再去匹配前面的x或者h的aha

?!   #负先行断言
(x|h)aha(?!\swo)       # 空格+wo是先决条件，但是不采纳，然后再去匹配前面的x或者h的aha

?<=     #正后发断言
(?<=(x|h)aha\s)(nihao|wo)   # 匹配nihao或者wo，但是先决条件是：前面跟的是x/haha+空格

?<!      #负后发断言
(?<=(x|h)aha\s)(nihao|wo)   # 匹配nihao或者wo，但是先决条件是：不采纳——前面跟的是x/haha+空格的
```





# php写正则替换



```
\s   # 匹配空格
\S   # 匹配除了空格的一切

<[a-zA-Z]+.*?>          # 匹配所有的前标签，问号是只匹配一次问号前的内容。不加问号就会把前标签所在的一行都匹配。
</[a-zA-Z]+.*?>          # 匹配所有的后标签

<[a-zA-Z]+.*?>([\s\S]*?)</[a-zA-Z]+.*?>   # 整块整块地匹配标签及内容
```



## 匹配ip地址

```
[0-1]?\d{1,2}   # 匹配0-199
                # [0-1]?  表示匹配 0或1 一次或零次
                # \d     表示匹配任意一个十进制数字，即 0~9
                # {1,2}   表示匹配上一个元素至少一次，最多两次，这里就是 \d一次或两次

2(0-4)\d        #匹配200-249

2((5[0-5]))     #匹配250-255

2((5[0-5])|(0-4)\d)     #匹配200-255

(\.(2((5[0-5])|(0-4)\d))){3}     #匹配.200-255.200-255.200-255

^(((([01]?\d\d?|2[0-4]\d|25[0-5]))\.){3})(([01]?\d\d?|2[0-4]\d|25[0-5]))$    
```



## php写正则替换

```php+HTML
<?php

$string = "haha 123 456 789";

//匹配的东西
$pa = '/(\w)/i';    //除了空格符号外的所有字符

echo preg_replace($pa,"xxx",$string);    
//实现替换：把$string里匹配到$pa的东西全部都替换成xxx

?>
```



### 正则表达式的`()`和`\\1`表示几号位，可以利用这点来传值

```php+HTML
<?php

$string1 = "haha 123 456 789";

//匹配什么东西
$pa = '/(\w+) (\d+) (\d+) (\d+)/i';

//匹配的东西替换为什么东西
$replace = 'nihao ${2} ${3}';


//preg_replace('/(\w+) (\d+) (\d+) (\d+)/i', 'nihao ${2} ${3}', "haha 123 456 789");
//                1      2     3     4
//               haha   123    456   789
//把haha 123 456 789按匹配要求匹配并分1，2，3，4位，替换成'nihao ${2} ${3}'即'nihao 2号位的东西 3号位的东西'

echo preg_replace($pa, $replace, $string1);

?>
```



`'${1}'`=`'\\1'`=`'$1'`=`'(.*)'`



## 匹配script标签里的内容

```
<script>alert(1)</script>

<[a-zA-Z]+.*?>          # 匹配所有的前标签，问号是只匹配一次问号前的内容。不加问号就会把前标签所在的一行都匹配。
</[a-zA-Z]+.*?>          # 匹配所有的后标签

(?<=(<script>))(\w+\(\d\))(?=(</script>))
(?<=(<script>))(.)(?=(</script>))
```






# 分析正则一句话

## 正则表达式里的修饰符

```
"/匹配内容/修饰符"

i 不区分(ignore)大小写；
例如: /abc/i 可以匹配 abc、aBC、Abc 


g 全局(global)匹配 
如果不带g，正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功，返回
如果带g，则字符串从左到右，找到每个符合条件的都记录下来，知道字符串结尾位置
例如: 
var str = 'aaaaaaaa'
var reg1 = /a/;  str.match(reg1)  // 结果为：["a", index: 0, input: "aaaaaaaa"]
var reg2 = /a/g; str.match(reg2)  // 结果为：["a", "a", "a", "a", "a", "a", "a", "a"]


m 多(more)行匹配
若存在换行\n并且有开始^或结束$符的情况下，和g一起使用实现全局匹配,
因为存在换行时默认会把换行符作为一个字符任务匹配字符串是个单行，
g只匹配第一行，添加m之后实现多行，每个换行符之后就是开始
var str = "abcggab\nabcoab";
var preg1 = /^abc/gm;  str.match(preg1)  // 结果为：["abc", "abc"]
var preg2 = /ab$/gm;   str.match(preg2)  // 结果为：["ab", "ab"]


s 特殊字符圆点 . 中包含换行符
默认的圆点 . 是 匹配除换行符 \n 之外的任何单字符，加上s之后, . 中包含换行符
$str = "abggab\nacbs";
$preg = "/b./s";
preg_match_all($preg, $str,$matchs);
print_r($matchs);//Array ( [0] => Array ( [0] => bg [1] => b [2] => bs ) ) 


U 只匹配最近的一个字符串;不重复匹配; 
$mode="/a(.*?)c/";
$preg="/a.*c/U";//这两个正则返回相同的值
$str="abcabbbcabbbbbc" ;
preg_match($mode,$str,$content);   echo $content[0];//abc
preg_match($preg,$str,$content);   echo $content[0];//abc


//修正符:x 将模式中的空白忽略; 
//修正符:A 强制从目标字符串开头匹配;
//修正符:D 如果使用$限制结尾字符,则不允许结尾有换行; 
//修正符:e 配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行;  
```



## 分析正则一句话

![image-20220118162553782](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/04%20%E5%88%86%E6%9E%90%E6%AD%A3%E5%88%99%E4%B8%80%E5%8F%A5%E8%AF%9D.assets/image-20220118162553782.png)

匹配[]里的东西并替换成自己本身。







# 关于日志审计

## 日志审计的目的

PHPstudy的日志存储地址：

![image-20220118162651600](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/05%20%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E5%AE%A1%E8%AE%A1.assets/image-20220118162651600.png)

### 目的：

安全人员看到了服务器的日志，通过正则表达式等工具分析日志，从日志里找到：黑客的ip，黑客发现了什么页面，页面反馈是多少，什么时候发现的

### 思路：

一般来说：

对于一般网站，其管理员的登录界面很可能是admin.php，黑客如果用工具扫到了这个网站（请求成功的话），那么请求结果（php回复结果）就会是200

`www.xx.com/admin.php`

那么如果后台的目录是多层或者非规律性的后台目录，并且访问结果是200：

`www.xx.com/affda/fsfa/admin.php ...  200`

可以看到上述两者的共性是：黑客一定会找到的文件是php文件，并且反馈是200。

**所以我们需要在行中匹配`php`并且匹配`200`，中间可能包含任意字符。**

### 扫描到后台的日志特征：

php+中间一堆+200



## 日志审计的方法

### 匹配：请求后台并成功的行为

```
php.+? 200

然后会找到/adminlogin.php HTTP/1.1" 200 
```



考试时，如果找到像admin的目录后，还需要在电脑上输入地址，通过登录后台，并用神器穷举出它的密码。






# php弱类型——php语言特性

###  PHP语言特性——web安全类漏洞

```php
highlight_file(__file__);在网页上显示php代码
```

#### 1 PHP弱类型

>php是一门弱类型的语言,它不会严格检验变量类型,变量可以不显示地声明其类型,而是在运行期间直接赋值。 在php中比较是否相等有两种符号： == 和 === 。

`==`在比较时会将不同类型的变量或值转换为相同类型再进行比较

`===`则直接比较类型是否相同，如果同类型，再比较值

##### 例：

127.0.0.1:8080/weak_type.php

```sql
• var_dump("a"==0); //true
• var_dump("1a"==1); //true
• var_dump("a1"==1); //false
• var_dump("a1"==0); //true
• var_dump(“0e123456”==“0e234567”); //true，科学计数法
• var_dump(0=="1a"); //false
```

>“ == ” 会在比较时自动转换类型而不改变原来的值，因此这个符号经常出现漏洞。“ == ” 比较相等的一些常见值如下，当某些语句的判断条件是使用 “ == ”来判断时，就可以使用弱类型来替代。值得一提的是 “0e” 开头的哈希字符串，PHP 在处理哈希字符串时会把每一个以 “0E” 开头的哈希值都解释为 0。——常见MD5碰撞

#### 2 Md5==绕过(0e比较)：

127.0.0.1/md5_1.php

```
?a=240610708
```

![image-20211204220400070](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/00%20php%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7.assets/image-20211204220400070.png)

```
0e开头的md5和原值：
QNKCDZO
0e830400451993494058024219903391
240610708
0e462097431906509019562988736854
s878926199a
0e545993274517709034328855841020
s155964671a
0e342768416822451524974117254469
s214587387a
0e848240448830537924465865611904
s214587387a
0e848240448830537924465865611904
s878926199a
0e545993274517709034328855841020
s1091221200a
0e940624217856561557816327384675
s1885207154a
0e509367213418206700842008763514
s1502113478a
0e861580163291561247404381396064
s1885207154a
0e509367213418206700842008763514
s1836677006a
0e481036490867661113260034900752
s155964671a
0e342768416822451524974117254469
s1184209335a
0e072485820392773389523109082030
s1665632922a
0e731198061491163073197128363787
s1502113478a
0e861580163291561247404381396064
s1836677006a
0e481036490867661113260034900752
s1091221200a
0e940624217856561557816327384675
s155964671a
0e342768416822451524974117254469
s1502113478a
0e861580163291561247404381396064
s155964671a
0e342768416822451524974117254469
s1665632922a
0e731198061491163073197128363787
s155964671a
0e342768416822451524974117254469
s1091221200a
0e940624217856561557816327384675
s1836677006a
0e481036490867661113260034900752
s1885207154a
0e509367213418206700842008763514
s532378020a
0e220463095855511507588041205815
s878926199a
0e545993274517709034328855841020
s1091221200a
0e940624217856561557816327384675
s214587387a
0e848240448830537924465865611904
s1502113478a
0e861580163291561247404381396064
s1091221200a
0e940624217856561557816327384675
s1665632922a
0e731198061491163073197128363787
s1885207154a
0e509367213418206700842008763514
s1836677006a
0e481036490867661113260034900752
s1665632922a
0e731198061491163073197128363787
s878926199a
0e545993274517709034328855841020
————————————————
版权声明：本文为CSDN博主「烟雨天青色」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_38603541/article/details/97108663
```

#### 3 md5===绕过(数组比较):

127.0.0.1/md5_2.php

```php
http://127.0.0.1/md5_2.php?a[]=a&b[]=b
上述的例子中传入?a[]=a&b[]=b即可满足既不相等，md5后又相等的条件,虽然报错，但仍然输出了正确的值。
```

>在php中的hash函数md5、sha1等处理中若传入一个数组的值，则会报错返回NULL，而返回的值在类型和内容上都是相同的，所以可以用来绕过某些两边参数可控的场景，上面只能控制一边的值传入，所以数组类型不适用。

![image-20211204221142002](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/00%20php%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7.assets/image-20211204221142002.png)

#### 4 md5===绕过(硬碰撞)

#### 5 json解码绕过

#### 6 array_search 绕过





# php弱类型——php之md5类型练习

## pass01

```php+HTML
 <?php
    error_reporting(0);
    highlight_file("pass-01.php");
    //

    if(isset($_GET["pass"])){
        if($_GET["pass"] != hash("md4", $_GET["pass"])){
            die('fail~~~');
        }else{
            echo "success!!!<br>";
            echo file_get_contents('flag.txt')."\n";
            echo "<a href='pass-02.php'>下一关</a>";
        }
    }else{
        echo "please input the pass";
    }
?> please input the pass
```



```
可以提交参数pass
```





## 小知识：

### php弱类型比较

从左往右比较：

`== `是比较数值，不比较类型【弱类型比较】

`===` 既比较数值，又比较类型【强类型比较】

>>php是一门弱类型的语言,它不会严格检验变量类型,变量可以不显示地声明其类型,而是在运行期间直接赋值。 在php中比较是否相等有两种符号： == 和 === 。
>
>`==`在比较时会将不同类型的变量或值转换为相同类型再进行比较
>
>`===`则直接比较类型是否相同，如果同类型，再比较值
>
>>“ == ” 会在比较时自动转换类型而不改变原来的值，因此这个符号经常出现漏洞。“ == ” 比较相等的一些常见值如下，当某些语句的判断条件是使用 “ == ”来判断时，就可以使用弱类型来替代。值得一提的是 “0e” 开头的哈希字符串，PHP 在处理哈希字符串时会把每一个以 “0E” 开头的哈希值都解释为 0。——常见MD5碰撞

```
var_dump(998=="998"); true

var_dump(998=="998ab"); true

var_dump(0=="haha"); true

var_dump(123===123); true

```





### md5绕过

md4和md5加密都有可能出现一个0e开头——php弱类型漏洞



### 如果利用这点去尝试写程序穷举MD4碰撞：

```
<?php

for($i=0;;$i++){
	$r = "0e".$i;         //$r=0e1,0e2......0e251288019...
	$md4 = hash("md4",$r);   //$md4 = 0e874956163641961271069404332409 
	echo '<br/>';
	echo $i;
	if(preg_match("/!0e[0-9]*$/",$md4)){
		echo "md4加密前".$r;
		echo "md4加密后",$md4;
		break;
	}
}

?>
```

得到`0e251288019`

```
<?php

$md4 = hash('md4','0e251288019')
echo "";
echo '<br/>';
echo 'md4';

?>
//可以对比再md4后的结果
```



## pass02

```
 <?php
    error_reporting(0);
    highlight_file("pass-02.php");

    if(isset($_GET['user']) && isset($_GET['pass'])){
        $user = $_GET['user'];
        $pass = $_GET['pass'];

        if($user != $pass && md5($user) == md5($pass)){
            echo "success!<br>";
            echo file_get_contents('flag.txt')."\n";
            echo "<a href='pass-03.php'>下一关</a>";
        }else{
            echo "fail~~~";
        }

    }else{
        echo "please input the user and pass!"."\n";
    }
?> please input the user and pass! 
```





## 小知识：

### md5碰撞穷举结果绕过

md5弱类型比较常见：

```
md5弱类型比较
IHKFRNS 0e256160682445802696926137988570
QLTHNDT 0e405967825401955372549139051580
QNKCDZO 0e830400451993494058024219903391
3908336290 0e807624498959190415881248245271
4011627063 0e485805687034439905938362701775
4775635065 0e998212089946640967599450361168
0e215962017 0e291242476940776845150308577824
aabg7XSs 0e087386482136013740957780965295
aabC9RqS 0e041022518165728065344349536299
```

```
0e开头的md5和原值：
QNKCDZO
0e830400451993494058024219903391
240610708
0e462097431906509019562988736854
s878926199a
0e545993274517709034328855841020
s155964671a
0e342768416822451524974117254469
s214587387a
0e848240448830537924465865611904
s214587387a
0e848240448830537924465865611904
s878926199a
0e545993274517709034328855841020
s1091221200a
0e940624217856561557816327384675
s1885207154a
0e509367213418206700842008763514
s1502113478a
0e861580163291561247404381396064
s1885207154a
0e509367213418206700842008763514
s1836677006a
0e481036490867661113260034900752
s155964671a
0e342768416822451524974117254469
s1184209335a
0e072485820392773389523109082030
s1665632922a
0e731198061491163073197128363787
s1502113478a
0e861580163291561247404381396064
s1836677006a
0e481036490867661113260034900752
s1091221200a
0e940624217856561557816327384675
s155964671a
0e342768416822451524974117254469
s1502113478a
0e861580163291561247404381396064
s155964671a
0e342768416822451524974117254469
s1665632922a
0e731198061491163073197128363787
s155964671a
0e342768416822451524974117254469
s1091221200a
0e940624217856561557816327384675
s1836677006a
0e481036490867661113260034900752
s1885207154a
0e509367213418206700842008763514
s532378020a
0e220463095855511507588041205815
s878926199a
0e545993274517709034328855841020
s1091221200a
0e940624217856561557816327384675
s214587387a
0e848240448830537924465865611904
s1502113478a
0e861580163291561247404381396064
s1091221200a
0e940624217856561557816327384675
s1665632922a
0e731198061491163073197128363787
s1885207154a
0e509367213418206700842008763514
s1836677006a
0e481036490867661113260034900752
s1665632922a
0e731198061491163073197128363787
s878926199a
0e545993274517709034328855841020
————————————————
版权声明：本文为CSDN博主「烟雨天青色」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_38603541/article/details/97108663
```



### 数组绕过

php的md5函数，无法处理数组，返回null

>#### md5===绕过(数组比较):
>
>127.0.0.1/md5_2.php
>
>```php
>http://127.0.0.1/md5_2.php?a[]=a&b[]=b
>上述的例子中传入?a[]=a&b[]=b即可满足既不相等，md5后又相等的条件,虽然报错，但仍然输出了正确的值。
>```
>
>>在php中的hash函数md5、sha1等处理中若传入一个数组的值，则会报错返回NULL，而返回的值在类型和内容上都是相同的，所以可以用来绕过某些两边参数可控的场景，上面只能控制一边的值传入，所以数组类型不适用。
>
>



## pass03

查穷举的表

```
ctype_alpha检测A-Za-z
is_numeric检查是否只有数字
```

```
/pass-03.php?user=3908336290&pass=QNKCDZO
```



## pass04

利用null

```
/pass-04.php?user=&pass[]=1
没有赋值就是空
```

没有赋值就是空

## pass05

===

利用null

```
/pass-05.php?user=&pass[]=1
```

## pass06

强制类型转换

穷举

```
240610708---aawBzC
```

`240610708`一次md5==`aawBzC`两次md5

`aawBzC`两次md5都是0e开头

## pass07

数组绕过

```
/pass-07.php?user[]=1&pass[]=2
```

## pass08

有string强制类型转换，且参数长度有限制

序列化和反序列化

php特定数据类型

```
POST
auth=O:4:"auth":2:{s:4:"user";d:INF;s:4:"pass";d:INF;}
```





## 小知识：

### 序列化&反序列化

```
<?php 

class auth{
	public $user;
	public $pass;

}

//把auth类实例化
$a = new auth();
$a->user="haha";
$a->pass="nihao";

echo serialize($a);
//进行序列化输出：
//O:4:"auth":2:{s:4:"user";s:4:"haha";s:4:"pass";s:5:"nihao";}
//（O对象，名auth长度为4，属性个数2，键为user类型string，值为haha，键为pass，值为nihao）


//反序列化
$str1 = 'O:4:"auth":2:{s:4:"user";s:5:"haha1";s:4:"pass";s:6:"nihao2";}';
$b = unserialize($str1);

echo $b->user;
//输出haha

?>
```

### php特定数据类型

#### NAN INF

 >- **NaN（NotaNumber，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE** 754浮点数标准。
 >- **INF** ：infinity （linux） 等同于 #**INF**:infinity (windows) nan ：not a number 等同于 #IND:indeterminate (windows) 注意： **inf**一般是因为得到的数值，超出浮点数的表示范围（溢出，即阶码部分超过其能表示的最大值）

序列化后：`d:INF`、`d:NAN`

```
var_dump('INF'==INF);//false
var_dump('INF'!==INF);//true
var_dump(md5('INF')===md5(INF));//true


echo '<br/>';
echo md5('INF');
echo '<br/>';
echo md5(INF);
```







# php弱类型——php反序列化

### PHP反序列化

>介绍一下序列化：无论什么语言，传递数据时，像对象数组这些数据类型没有一个统一的规则，无法传输，将各种数据类型按照一定的规则转换为字符串，从而方便保存与传递

![image-20211204221247306](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20211204221247306.png)

>• php序列化只序列化对象属性，不序列化序列化对象的方法，完全忽略掉：
>
>公有属性——属性名
>
>私有属性——%00类名%00属性名（打印时，无论是echo还是啥，是看不到%00的，这种情况不能直接输出，会丢掉%00，需要进行url编码或者base64编码等编码形式输出）
>
>保护属性：%00*%00属性名

#### 例：

127.0.0.1:8080/serialize_1.php

![image-20211204221519937](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20211204221519937.png)



#### 1 魔术方法

>正是有这些魔术方法，反序列化漏洞的危害才会那么大。
>
>> **魔术方法**是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作。
>
>> 在Python中，所有以双下划线`__`包起来的方法，统称为**Magic Method（魔术方法）**，它是一种的特殊方法，普通方法需要调用，而魔术方法不需要调用就可以自动执行。
>
>> 魔术方法在类或对象的某些事件出发后会自动执行，让类具有神奇的“魔力”。如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。
>
>> PHP 保留所有以 `__` 开头的方法名称。 因此，除非覆盖 PHP 的行为，否则不建议使用此类方法名称。
>
>> > **magic函数**是Python的一种高级语法，允许你在类中自定义函数（函数名格式一般为__xx__），并绑定到类的特殊方法中。 比如在类A中自定义__str__ ()函数，则在调用str (A ())时，会自动调用__str__ ()函数，并返回相应的结果。

#### 2 magic函数，在特定的情况下会被自动调用

```
• __ construct：在对象诞生时调用

• __ destruct：对象被销毁时调用 （最重要，因为程序肯定会结束，一结束，对象就会被销毁，被销毁就会调用，所以只要对象被反序列化处理，等于是无条件被调用）

• __ toString：对象被打印或者强行转为字符串时被调用

• __ wakeup：对象被反序列化时被调用 （听起来很契合，但是利用不常见，一般waf或者过滤操作都写在wakeup函数里，所以一般达不到效果）

• __invoke：调用函数的方式调用一个对象时的回应方法

• __call，在对象中调用一个不可访问方法时调用
```

#### 3 绕过__wakeup

​	• 对象被反序列化时首先调用__wakeup函数，可能会存在一些过滤

​	• 绕过方法：**CVE-2016-7124**（如果题中看到需要绕过wakeup，大概率就是这个cve，其他没啥办法）

​	• 利用方式：==序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行==

​	• 使用范围：PHP5<5.6.25 PHP7<7.0.10

##### 例：

127.0.0.1:8080/serialize_3.php

![image-20211204224009845](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20211204224009845.png)

> 注意注意！！：
>
> a,b分别是两个序列化的字符串：
>
> $a='O:4:"test":1:{s:1:"a";s:3:"abc";}';（O对象名test长度为4，属性个数1，键为a，值为abc）
>
> 此时属性为1，对象属性个数的值等于真实的属性个数，执行wakeup
>
> $b='O:4:"test":2:{s:1:"a";s:3:"abc";}';（O对象名test长度为4，属性个数2，一个属性键为a，值为abc）
>
> 此时属性为2，对象属性个数的值大于真实的属性个数，绕过wakeup



#### 4 绕过部分正则

• 一些题目利用正则检查序列化字符串是否是对象字符串开头

`（（preg_match('/^O:\d+/’)）`

##### 绕过方法：

​		• 利用加号绕过：O:+4开头(测试后发现PHP7.2以上好像不行；注意在url里传参时+要编码为%2B) 

​		• 利用数组：serialize(array(a))，就会时a:开头

##### 利用数组：serialize(array(a))，就会是a:开头

##### 例：127.0.0.1:8080/serialize_4.php

![image-20211204224503764](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20211204224503764.png)

//a:array代表是数组，后面的3说明有三个属性

//i:代表是整型数据int，后面的0是数组下标

//s:代表是字符串，后面的4是因为xiao长度为4

#### 5 十六进制绕过

> 正则过滤了很多字符，可以尝试使用十六进制绕过

https://tool.ip138.com/ascii_code/

##### 例：

127.0.0.1:8080/serialize_6.php

![image-20211204224813455](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20211204224813455.png)

打开源码改l或a或g为ASCII码形式都可

#### 6 反序列化字符逃逸

> 在反序列化之前对序列化字符串进行字符串替换操作，可能会造成替换后字符变多/变少，使得外部输入的对象属性逃逸出来，从而构造任意对象反序列化。

##### • 分序列化字符逃逸分析

```sql
//正常情况下
O:4:"User":2:{s:8:"username";s:10:"1234567890";s:8:"password";s:10:"0123456789";}

//username带有一个\0*\0，替换后：
O:4:"User":2:{s:8:"username";s:15:"1234567890N*N";s:8:"password";s:10:"0123456789";}
//吃掉了后面两个字符

//如果吃掉更多字符，让我们可以控制password为一个对象呢？
O:4:"User":2:{s:8:"username";s:58:“pmj\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0\0*\0";s:8:"password";s:53:";s:8:"password";O:4:"king":1:{s:1:"a";S:4:"\66lag";}}";}

```

##### • 过滤后字符变多的情况

![image-20211204225126254](https://github.com/YTR1020/Trees/blob/main/Screenshot%20or%20pictures/HW/Attack/02%20php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20211204225126254.png)

```sql
• x->xx的情况

• name=xxxxxxxxxxxxxxxxxxxx";i:1;s:6:"whoami";}

• s:40:”xxxxxxxxxxxxxxxxxxxx”; i:1;s:6:“whoami”;}”;i:1;s:7:"I am 11";}“

• 多出20个x，将我们的payload顶出去了，而后面的”;i:1;s:7:“I am 11”;}“被舍弃
```

#### 7 步骤总结

##### 步骤：

​		• 构造payload，计算长度

​		• 计算过滤规则，什么字符串会增加/减少n位

​		• N*n=length(payload)

##### 总结：

​		• 字符逃逸，一定是先序列化，然后通过过滤等措施使得字符串长度发生变化，然后反序列化处理，从而实现了逃逸







